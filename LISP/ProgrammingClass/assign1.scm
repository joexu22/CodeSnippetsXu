(define (author)
    (println "AUTHOR: Guanzhou Xu gxu2@crimson.ua.edu")
    )

(define (exprTest # $expr target)
    (define result (catch (eval $expr #)))
    (if (error? result)
        (println $expr " is EXCEPTION: " (result'value)
            " (it should be " target ")")
        (println $expr " is " result
            " (it should be " target ")")
        )
    )

(define (run1)
    (println "a = #t, b = \"no-error\", c = failplz \(an undefined function\)\n")
    (println "(if a b c) result: " (catch(if #t "no-error" (failplz))))
    (println "(my-if a b c) result: " (catch(my-if #t "no-error" (failplz))))
    (println "\n\"if\" does not result in a error because it is a special form that will only evaluate the \"consequent\" if the the predicate is true")
    (println "\"my-if\" results in a error because it is a procedure which will attempt to evaluate all of its arguments\"\n")
    )

(define (my-if a b c)
    (if (true? a)
        b
        c
        )
    )

(define (run2)
    ; some test case from the forum
    (exprTest (zeno_cost 1 1 2) 16390.000000)
    (exprTest (zeno_cost 2 10 3) 7.174454e7)
    (exprTest (zeno_cost 8 10 2) 1310717.0000)
    (exprTest (zeno_cost 16 10 0.5000000000) 19.927083333)
    (exprTest (zeno_cost 128 2 0.5000000000) 3.9583333333)
    (exprTest (zeno_cost 0.0002000000 10 3) 17.000000000)
    (exprTest (zeno_cost 128 2 0.5000000000) 3.9583333333)
    (exprTest (zeno_cost 0.0008000000 10 2) 77.000000000)
    (exprTest (zeno_cost 16 10 0.5000000000) 19.927083333)
)

(define (zeno_cost d c f)
    (cond ((<= d (/ 1.0 9600)) 7)
          ((<= c (/ 1.0 12)) (/ 1.0 12))
          (else (+ c (zeno_cost (/ d 2.0) (* c f) f)))))

(define (run3)
    (exprTest ((mandelbrot-iter 100) 0.5 0.5) 5)
    (exprTest ((mandelbrot-iter 100) 2 3) 1) 
    (exprTest ((mandelbrot-iter 100) 0 0) 0) 
    )

;(define mandelbrot-tester (mandelbrot-iter 100))
;(if (= (mandelbrot-tester 2 3) 0)
;    (print "point (2,3) is in the Mandelbrot set!\n")
;    (print "point (2,3) is not in the Mandelbrot set.\n")
;    )
(define (mandelbrot-iter threshold)
    (lambda (x y)
        (define (r-next r s x)
            (+ (- (* r r) (* s s)) x)
        )
        (define (s-next r s y)
            (+ (* 2 r s) y)
        )
        (define (iter x y r s count)
            (cond
                ((> (+ (* r r) (* s s)) 4) count)
                ((> count threshold) 0)
                (else (iter x y (r-next r s x) (s-next r s y) (+ count 1)))
            )
        )
        (iter x y 0.0 0.0 0)
    )
)


(define (run4)
    (exprTest (root3 0) 0)
    (exprTest (root3 1) 1)
    (exprTest (root3 125) 5)
    (exprTest (root3 1000) 10)
    (exprTest (root3 2000000) (^ 2000000 (/ 1.0 3)))
    (exprTest (root3 (^ .123 3)) .123)
    (exprTest (root3 (^ .34324 3)) .34324)
    )

(define (root3 x)
    (define (root-iter high mid low last)
        (cond
            ((= last (new-mid high low)) last)
            ((> (** mid 3) x) (root-iter mid (new-mid high low) low mid))
            (else (root-iter high (new-mid high low) mid mid))
        )
    )
    (define (new-mid h l) (/ (+ h l) 2.0))
    (cond
        ((= x 0) 0)
        ((> x 1) (root-iter x (new-mid x 1) 1 x)) 
        (else (root-iter 1 (new-mid 1 0) 0 x))
    )
)

(define (run5)
    (crazyTriangle 1 1 13)
    ;(crazyTriangle 1 1 15)
    (crazyTriangle 2 3 10)
    )

(define (crazyTriangle left right depth)
    (define (tree-print depth)
        (define (tree-iter c d i)
            (cond
                ((> i 1) (print " ") (tree-iter c d (- i 1)))
                ((> c d) (print "\n") (tree-iter 0 (+ d 1) (- depth d 1)))
                ((< d depth) (print (get-pascal-num c d) " ") (tree-iter (+ c 1) d i))
            )
        )
        (tree-iter 0 0 depth)
    )
    (define (get-pascal-num col depth)
        (cond
            ((= col 0) left)
            ((= col depth) right)
            (else (+ (get-pascal-num (- col 1) (- depth 1)) (get-pascal-num col (- depth 1))))
        )
    )
    (tree-print depth)
)

(define (run6)
    (exprTest (((((oppy +) 1) +) 1) 1) 3)
    (exprTest (((((oppy -) 1) *) 1) 1) 0)
    (exprTest (((((oppy *) 2) /) 8) 4) 4)
    (exprTest (((((oppy /) 5) -) 1) 1) "error")
    (exprTest (((((oppy ^) 3) +) 1) 1) 9)
    (exprTest (((((oppy %) 9) *) 1) 2) 1)
    (exprTest (((((oppy *) 1) ^) 1) 1) 1)
    (exprTest (((((oppy /) 1.0) +) 1) 1) .5)
)

(define (oppy op1)
    (lambda (x)
        (lambda (op2)
            (lambda (y)
                (lambda (z)
                    (op1 x (op2 y z))
                )
            )
        )
    )
)


(define (run7)
    (exprTest (w (lambda (x) (+ x 2)) 7) -46)
    (exprTest (w (lambda (x) (+ (^ x 2) 1)) 1) (- (/ 1.0 3)))
    (exprTest (w (lambda (x) (+ (^ x 2) 5)) 2) -5.2)
    
)

(define (w f i)
    (cond
        ((= i 0) (f i))
        (else (Shank f i))
    )
)

(define (Shank f i)
    (let 
        (
        (A (S f (+ i 1)))
        (B (S f (- i 1)))
        (C (S f i))
        )
    (/ (- (* A B) (* C C)) (- (+ A B) (* 2.0 C)))
    )
)

(define (S f n)
    (sum f 0 inc n)
)

(define (sum term a next b)
    (if (> a b)
        0
        (+ (term a) (sum term (next a) next b))
    )
)


(define (run8)
    (exprTest (egypt* 0 0) 0)
    (exprTest (egypt* 10 0) 0)
    (exprTest (egypt* 0 10) 0)
    (exprTest (egypt* 1 1) 1)
    (exprTest (egypt* 2 22) 44)
    (exprTest (egypt* 9 77) (* 9 77))
    (exprTest (egypt* 60 120) 7200)
    ;(exprTest (egypt* 1000 1000) 1000000)
    (exprTest (halve 9) 4)
    (exprTest (halve 77) 38)
    (exprTest (halve 0) 0)
    (exprTest (halve 1) 0)
    (exprTest (halve 2) 1)
)
(define (egypt* b c)
    (define (iter-up a b c d)
        (cond
            ((> a b) (iter-down a b c d))
            (else (iter-up (+ a a) b (+ c c) d))
        )
    )
    (define (iter-down a b c d)
        (cond
            ((= b 0) d)
            ((<= a b) (iter-down (halve a) (- b a) (halve c) (+ c d)))
            (else (iter-down (halve a) b (halve c) d))
        )
    )
    (iter-up 1 b c 0)
)

(define (halve x)
    (define (iter-half x y z)
        (cond
            ((<= x 1) 0)
            ((< x y) (- z 1))
            (else (iter-half x (+ y 2) (+ z 1)))
        )
    )
    (iter-half x 0 0)
)


(define (run9)
    (inspect (mystery 0))
    (inspect (mystery 1))
    (inspect (mystery 2))
    (inspect (mystery 5))
    (inspect (mystery 10))
    (inspect (mystery 20))
    (inspect (mystery 50))
    (inspect (mystery 100))
    (inspect (mystery 115))
    (println "the value if given infinite terms converges to: (^ 3 .5)")
)

(define (mod2 x)
    (cond
        ((= 1 (% x 2)) 1)
        (else 2)
    )
)

(define (cont-frac n)
    (define (recur i)
        (if (> i n)
            0.0
            (/ 1.0 (+ (mod2 i) (recur (+ i 1))))
        )
    )
    (recur 1)
)

(define (mystery n)
    (+ 1 (cont-frac n))
)

(define (run10)
    (inspect (ramanujan 0 3))
    (inspect (ramanujan 1 3))
    (inspect (ramanujan 2 3))
    (inspect (ramanujan 5 3))
    (inspect (ramanujan 10 3))
    (inspect (ramanujan 20 3))
    (inspect (ramanujan 50 3))
    (inspect (ramanujan 100 3))
    (inspect (iramanujan 0 3))
    (inspect (iramanujan 1 3))
    (inspect (iramanujan 2 3))
    (inspect (iramanujan 5 3))
    (inspect (iramanujan 10 3))
    (inspect (iramanujan 20 3))
    (inspect (iramanujan 50 3))
    (inspect (iramanujan 100 3))
    
    (inspect (ramanujan 100 1)) 
    (inspect (iramanujan 100 1))
    (inspect (ramanujan 100 2)) 
    (inspect (iramanujan 100 2))
    (inspect (ramanujan 100 10)) 
    (inspect (iramanujan 100 10))
    (inspect (ramanujan 100 50)) 
    (inspect (iramanujan 100 50))
    (println "the function converges to in terms of x is: \"x + 1\"")
)

(define (ramanujan n x)
    (define (recur i)
        (if (> i n)
            0.0
            (^ (+ 1 (* (+ x i) (recur (+ i 1)))) .5)
        )
    )
    (if (= n 0)
        0
        (recur 0)
    )
)

(define (iramanujan n x)
    (define (iter-r i result)
        (if (= i 0)
            result
            (iter-r (- i 1)
                (^ (+ 1 (* (- (+ x i) 1) result)) .5)
            )
        )
    )
    (if (= n 0)
        0
        (iter-r n 1)
    )
)

;{
(run1)
(run2)
(run3)
(run4)
(run5)
(run2)
(run2)
(run2)
(run2)
(run2)
(run6)
(run7)
(run8)
(run9)
(run10)
;}
